{"version":3,"sources":["ModelFBX.tsx","Spinner.tsx","Scene.tsx","Controls.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["ModelFBX","modelUrl","textureUrl","position","model","useLoader","FBXLoader","texture","TextureLoader","traverse","child","isMesh","material","MeshPhongMaterial","map","skinning","useState","AnimationMixer","mixer","useEffect","animation","animations","clipAction","play","useFrame","state","delta","update","object","geometry","BoxGeometry","spinnerGeometry","EdgesGeometry","spinnerMaterial","LineBasicMaterial","color","linewidth","Spinner","target","setTarget","spinnerRef","useRef","useFrameCallback","useMemo","current","rotation","z","ref","cameraSettings","fov","aspect","window","innerWidth","innerHeight","near","far","Floor","Math","PI","receiveShadow","attach","args","transparent","opacity","Characters","modelsGroup","process","Scene","camera","useThree","Object","assign","set","lookAt","fallback","extend","OrbitControls","Controls","gl","domElement","App","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.8ed4520f.chunk.js","sourcesContent":["import React, { useState, useEffect } from 'react';\nimport { useLoader, useFrame } from 'react-three-fiber';\nimport { FBXLoader } from 'three/examples/jsm/loaders/FBXLoader';\nimport { TextureLoader, MeshPhongMaterial, AnimationMixer } from 'three';\n\nconst ModelFBX: React.FC<{ modelUrl: string, textureUrl: string, position: number[] }> =\n  ({ modelUrl, textureUrl, position }) => {\n    const model = useLoader(FBXLoader, modelUrl);\n    const texture = useLoader(TextureLoader, textureUrl);\n\n    model.traverse(child => {\n      if ((child as THREE.Mesh).isMesh) {\n        (child as THREE.Mesh).material = new MeshPhongMaterial({ map: texture, skinning: true });;\n      }\n    });\n\n    const [mixer] = useState(() => new AnimationMixer(model))\n    useEffect(() => {\n      const animation = (model as any).animations[0];\n      const action = mixer.clipAction(animation);\n      \n      action.play();\n    }, []);\n\n    useFrame((state, delta) => {\n      mixer.update(delta)\n    })\n\n\n    return <primitive object={model} position={position} />\n  }\n\nexport { ModelFBX };\n","import React, { useRef, useState, useMemo } from 'react';\nimport { BoxGeometry, LineBasicMaterial, EdgesGeometry } from 'three';\nimport { useFrame } from 'react-three-fiber';\n\nconst boxSize = 5;\nconst geometry = new BoxGeometry(boxSize, boxSize, boxSize);\nconst spinnerGeometry = new EdgesGeometry(geometry);\nconst spinnerMaterial = new LineBasicMaterial({color: 0x6e6e6e, linewidth: 100});\n\nconst Spinner: React.FC<{ position: [number, number, number] }> = ({ position }) => {\n  const [target, setTarget] = useState('up');\n  const spinnerRef = useRef<THREE.Mesh>();\n  const useFrameCallback = useMemo(() => () => {\n    spinnerRef.current!.rotation.z += 0.02;\n\n    if(target === 'up') {\n      spinnerRef.current!.position.z += 0.015;\n    }\n    if(target === 'down') {\n      spinnerRef.current!.position.z -= 0.015;\n    }\n\n    if(spinnerRef.current!.position.z > 1) {\n      setTarget('down');\n    }\n\n    if(spinnerRef.current!.position.z < -1) {\n      setTarget('up');\n    }\n  }, [target]);\n\n  useFrame(useFrameCallback);\n\n  return (\n    <lineSegments\n      ref={spinnerRef}\n      geometry={spinnerGeometry}\n      material={spinnerMaterial}\n      position={position}\n    />\n  )\n}\n\nexport { Spinner };","import React, { Suspense, useEffect, useRef } from 'react';\nimport { useThree } from 'react-three-fiber';\nimport { useModelCentering, centerCameraOn } from './useModelCentering';\nimport { ModelFBX } from './ModelFBX';\nimport { Spinner } from './Spinner';\n\nconst cameraSettings = {\n  fov: 45,\n  aspect: window.innerWidth / window.innerHeight,\n  near: 0.1,\n  far: 1000,\n};\n\nconst modelUrl = process.env.PUBLIC_URL + '/assets/Dance.fbx';\nconst modelUrl2 = process.env.PUBLIC_URL + '/assets/Mixamo.fbx';\nconst modelUrl3 = process.env.PUBLIC_URL + '/assets/Mixamo2.fbx';\nconst textureUrl = process.env.PUBLIC_URL + '/assets/texture.png';\n\nconst Floor: React.FC<{}> = () => (\n  <mesh rotation={[-0.5 * Math.PI, 0, 0]} receiveShadow>\n    <planeGeometry attach=\"geometry\" args={[5000, 5000, 1, 1]}/>\n    <meshLambertMaterial attach=\"material\" color=\"#9b9b9b\" transparent opacity={0.2} />\n  </mesh>\n);\n\nconst Characters: React.FC<{}> = () => {\n  const modelsGroup = useRef<THREE.Group>();\n\n  return (\n    <group ref={modelsGroup}>\n      <ModelFBX modelUrl={modelUrl} textureUrl={textureUrl} position={[-150, 0, 0]} />\n      <ModelFBX modelUrl={modelUrl2} textureUrl={textureUrl} position={[0, 0, 0]} />\n      <ModelFBX modelUrl={modelUrl3} textureUrl={textureUrl} position={[150, 0, 0]} />\n    </group>\n  );\n}\n\nconst Scene: React.FC<{}> = () => {\n  const { camera } = useThree();\n  Object.assign(camera, cameraSettings);\n  camera.position.set(0, 200, 300);\n  camera.lookAt(0, 0, 350);\n\n  return (\n    <>\n      <ambientLight args={[0xffffff, .25]} />\n      <pointLight args={[0xffffff, 1, 500]} position={[-150, 50, 100]}/>\n      <pointLight args={[0xffffff, 1, 500]} position={[50, 50, 50]}/>\n      <Suspense fallback={<Spinner position={[-150, 0, 0]} />}>\n        <Characters />\n      </Suspense>\n      {/* <Suspense fallback={<Spinner position={[-150, 0, 0]} />}>\n        <ModelFBX modelUrl={modelUrl} textureUrl={textureUrl} position={[-150, 0, 0]} />\n      </Suspense>\n      <Suspense fallback={<Spinner position={[0, 0, 0]} />}>\n        <ModelFBX modelUrl={modelUrl2} textureUrl={textureUrl} position={[0, 0, 0]} />\n      </Suspense>\n      <Suspense fallback={<Spinner position={[150, 0, 0]} />}>\n        <ModelFBX modelUrl={modelUrl3} textureUrl={textureUrl} position={[150, 0, 0]} />\n      </Suspense> */}\n      <Floor />\n    </>\n  );\n};\n\nexport { Scene };","import React, { useRef } from 'react';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\nimport { ReactThreeFiber, extend, useThree, useFrame } from 'react-three-fiber';\nextend({ OrbitControls });\n\ndeclare global {\n  namespace JSX {\n    interface IntrinsicElements {\n      orbitControls: ReactThreeFiber.Object3DNode<OrbitControls, typeof OrbitControls>\n    }\n  }\n}\n\nconst Controls = () => {\n  const ref = useRef<OrbitControls>();\n  const { camera, gl } = useThree();\n  useFrame(() => ref?.current?.update());\n\n  return (\n    <><orbitControls ref={ref} args={[camera, gl.domElement]} /></>\n  );\n}\n\nexport { Controls };","import React from 'react';\nimport { Canvas } from 'react-three-fiber';\nimport { Scene } from './Scene';\nimport { Controls } from './Controls';\n\nconst App = () => {\n\n  return (\n    <Canvas camera={{\n      fov: 75,\n      near: 0.1,\n      far: 10000,\n    }}>\n      <Controls />\n      <Scene />\n    </Canvas>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}